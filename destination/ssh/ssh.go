package ssh

import (
	"fmt"
	"html/template"
	"log"
	"os"
	"time"

	"github.com/Xuanwo/tiresias/config"
	"github.com/Xuanwo/tiresias/constants"
	"github.com/Xuanwo/tiresias/model"
	"github.com/Xuanwo/tiresias/utils"
)

const sshConfigTemplate = `Host {{ .Name }}
    HostName {{ .Address }}
    {{- if .User }}
    User {{ .User }}
    {{- end }}
    {{- if .Port }}
    Port {{ .Port }}
    {{- end }}
    {{- if .IdentityFile }}
    IdentityFile {{ .IdentityFile }}
    {{- end }}

`

// SSH is used to update SSH Config
type SSH struct {
	Path string

	tmpl *template.Template
}

// Init will initiate SSH.
func (ss *SSH) Init(c config.Endpoint) (err error) {
	ss.Path = c.Path

	// Init template.
	ss.tmpl, err = template.New("ssh_config").Parse(sshConfigTemplate)
	if err != nil {
		return
	}

	// Init ssh config.
	sf, err := os.OpenFile(ss.Path, os.O_RDWR|os.O_CREATE, 0600)
	if err != nil {
		log.Fatal(err)
	}
	defer sf.Close()
	// Seek to the start point of last update.
	cur, err := utils.Seek(sf)
	if err != nil {
		log.Fatal(err)
	}
	err = sf.Truncate(cur)
	if err != nil {
		log.Fatal(err)
	}
	_, err = sf.WriteString(fmt.Sprintf("%sGenerated by %s at %s%s\n",
		constants.CommentPrefix, constants.Name, time.Now(), constants.CommentSuffix))
	if err != nil {
		log.Fatal(err)
	}

	return
}

// Write will write servers into ssh config.
func (ss *SSH) Write(s ...model.Server) (n int, err error) {
	sf, err := os.OpenFile(ss.Path, os.O_RDWR|os.O_APPEND, 0600)
	if err != nil {
		log.Fatal(err)
	}
	defer sf.Close()

	for _, v := range s {
		err = ss.tmpl.Execute(sf, v)
		if err != nil {
			log.Fatalf("Template generate failed for %v", err)
		}
	}

	return len(s), nil
}
